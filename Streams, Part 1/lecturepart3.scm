#lang scheme 

; You should be starting to get suspicious. This simple elegant way is very unlike the 
; traditional programs that mix up the iterator, accumulator and filter. And by mixing it up 
; we don't have all these wonderful components.

; Why do all programs look like these ugly ones?

; Do computer scientists not notice? Why don't they write programs with such elegance?
; There's got to be a catch.

; It's easy to see. Here's an example.

;;; find the second prime between
;;; 10.000 and 1.000.000

(head ; head of tail is second element
 (tail (filter
        prime?
        (enum-interval 10000 1000000))))
 
 
; INTERVAL 10,000, 1,000,000 -> FILTER PRIME? ->
       
; That is pretty ridiculous. See we don't have enough space in the machine to store all the
; integers let alone check for prime and get only the second one.

; The power of the traditional style is exactly its weakness. We don't do it all. But the
; thing that makes it conceptually ugly is the thing that makes it efficient.

; Why did I show this wonderfully way in which programming might work instead of it doesn't?

; Here is the wonderfulness. We can really have our cake and eat it too. What I mean by that
; is that we can really write stream programs just like I wrote and it can run as efficient 
; as the general programming style that mixes up the generating and the test.

; The key is that streams are NOT lists.

; There is tugging on the box of the filter who is tugging on the box of the integers.

; No other computation gets done unless you tug on it.

; How do we make such a stream?

; We want to arrange for a stream to be a data structure that sorts of computes itself
; incrementally. Sort of an on-demand data structure.

; The basic idea is that there's not a firm distinction between programs and data. It is
; simultaneously a data structure and a procedure that has the method of computing it.

CONS-STREAM
HEAD
TAIL

; you can think about it like it's CONS, CAR or CDR but it is not. Let's look at what it is.

(cons-stream x y)
; abbreviation for
(cons x (delay y))

(head s) -> (car s)
(tail s) -> (force (cdr s))

; Let me explain delay and force

; What delay does is take an expression and produce a PROMISE that you will get the value
; if you ask for it. It does not do any computation.
; And cons-stream puts together x and a promise to compute y.
; The tail is going to be FORCE calling the promise.
; Force says take that promise and compute it.

(head (tail (filter prime? (e-l 10000 1000000))))
;                            (cons 10000
;                                   (delay (e-l 10001 1000000)))  
;            (filter prime?
;                     (cons (cons 10000 (delay (e-l 10001 1000000))))
;                                   force-^
;                              (e-l 10001 10000)
;                              (cons 10000) delay
;                                         (e-l 10002 1000000
;                     (...)
;             (cons 10009 (delay (filter prime? ....


; We can use substitutation model since we do not have state.

; No more gets generated then you actually need. No more will be generated by e-l than the 
; filter asks for, and no more will be asked of the filter than the head of the tail.

; You see we put that mixing of generating and test in another way than it is happening
; in the computer.

(delay <exp>)
abbreviation for (lambda () <exp>)

(force p) = (p) ; just run it

; What have we done:
; The old style of programming is more efficient, and the stream thing is more perspicuous
; and we managed to make the stream thing run like the other procedures by using delay.

; And what delay does is decouple the apparent order of events in our programs from the 
; actual order of events in the machine.

; We have given up the idea that procedures as we look at them mirror some clear notion of
; time. By giving that up we give delay the freedom to arrange the order of events in the 
; computation the way it likes.

; There's one more detail...

; As you run through this recursive programs unwinding you see a lot of things like:

(tail (tail (tail .... )))

; If each time I am doing that I have to evaluate a procedure that then has to recompute
; its own tail who recomputes its own tail et cetera you see that is very inefficient.

; There's one little hack to slightly change the abbreviation and make delay a thing.

(delay <exp>)      } (memo-proc
abbreviation for         (lambda () <exp>))

; memo-proc is something that makes delay only have to do its calculation once.
; You give it a procedure and the result of memo-proc will be that the first time you call
; it it will run the original procedure, remember what result it got and for every run after
; it it will have cached that result some place.

(define (memo-proc proc)                 ; memo-proc transform a procedure of no arguments
  (let ((already-run? nil)               ; Two little flags, both null: Have I already run? 
        (result nil))                    ; And what was the result the last time I run?
    (lambda ()                           ; It returns a new procedure of no arguments.
      (if (not already-run?)             ; If I have not already run
          (sequence                      ; I am going to do a sequence of things:
            (set! result (proc))         ; I am going to compute proc and save that in result
            (set! already-run? (not nil)); and I make a note to myself that I have run
            result)                      ; and I return the result.
          result))))                     ; If I have already run I just return the result.

; That's a little hack that's called memoization. This case it short-circuits having to
; recompute the tail of the tail of the tail. 

; This makes streams run with the same efficiency as the other programs precisely.

; The fact that there is no clear dividing line between data and procedures has allowed us
; to write data structures that are like procedures. What we did is take an example of 
; a common control structure, in this case iteration, and we built a data structure that
; acts like a procedure and therefore has this control structure in it. 

; That is what streams are.


; Questions:

; Does memoization not only work if the result is always the same?
; => Yeah, sure. Once I found the tail of the tail I should not have to recompute the tail.

; We are able to ues the substitution model because there are no side effects. What if we 
; have a procedure that has side effects? Could we practically use the stream model?
; => Maybe, that's a hard question. Substitution and side effects don't mix very well.
;    In general any amount of side effects is going to mess up everything.
